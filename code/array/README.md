# Go言語によるカスタム配列実装

このプロジェクトでは、Go言語の組み込み機能を使わずに静的配列と動的配列を実装し、組み込みの配列・スライスとのパフォーマンス比較を行います。

## ファイル構成

### 実装ファイル
- `custom_array.go` - カスタム実装の静的配列・動的配列
- `custom_array_demo.go` - カスタム実装のデモ（単体テスト）
- `array_comparison.go` - 組み込み配列との比較・パフォーマンステスト
- `array.go` - 元の統合ファイル（後方互換性のため）

### その他
- `Makefile` - 実行用のMakefile
- `README.md` - このファイル

## 実装内容

### 静的配列 (StaticArray)
- 固定サイズの配列
- 基本的な取得・設定操作
- 境界チェック付きアクセス

**主要メソッド:**
- `NewStaticArray(size int)` - コンストラクタ
- `Get(index int)` - 要素の取得 O(1)
- `Set(index int, value int)` - 要素の設定 O(1)
- `Size()` - サイズの取得

### 動的配列 (DynamicArray)
- 可変サイズの配列
- 自動的な容量拡張
- 挿入・削除・検索機能

**主要メソッド:**
- `NewDynamicArray()` - コンストラクタ
- `Append(value int)` - 末尾への追加 平均O(1)
- `Insert(index int, value int)` - 指定位置への挿入 O(n)
- `Delete(index int)` - 指定位置からの削除 O(n)
- `Pop()` - 末尾からの削除 O(1)
- `Get(index int)` - 要素の取得 O(1)
- `Set(index int, value int)` - 要素の設定 O(1)
- `IndexOf(value int)` - 値の検索 O(n)
- `Contains(value int)` - 値の存在確認 O(n)
- `Clear()` - 配列のクリア
- `ToSlice()` - スライスとしてエクスポート

## 実行方法

### Makefileを使用する場合

```bash
# カスタム実装のデモのみ
make demo

# 組み込み配列との比較・パフォーマンステスト
make comparison

# 元のファイル（統合版）
make custom

# すべて実行
make all
```

### 直接実行する場合

```bash
# カスタム実装のデモ
go run custom_array.go custom_array_demo.go

# 比較・パフォーマンステスト
go run custom_array.go array_comparison.go

# 元のファイル
go run array.go
```

## 特徴

1. **組み込み関数を使わない実装**
   - `append()`、`copy()`などの組み込み関数を使わずに実装
   - 手動でのメモリ管理と要素のシフト

2. **パフォーマンス測定**
   - 各操作の実行時間を測定
   - メモリ使用量の表示

3. **エラーハンドリング**
   - 境界チェック
   - 適切なエラーメッセージ

4. **詳細な情報表示**
   - 配列の状態（長さ、容量、使用率）
   - 容量拡張のログ

## パフォーマンス特性

| 操作 | 静的配列 | 動的配列 | Go スライス |
|------|----------|----------|-------------|
| アクセス | O(1) | O(1) | O(1) |
| 末尾追加 | - | 平均O(1) | 平均O(1) |
| 中間挿入 | - | O(n) | O(n) |
| 中間削除 | - | O(n) | O(n) |
| 検索 | O(n) | O(n) | O(n) |

## 学習ポイント

1. **配列の内部構造**
   - メモリレイアウト
   - 容量拡張のメカニズム

2. **時間計算量**
   - 各操作のBig O記法
   - 最良・平均・最悪ケース

3. **メモリ管理**
   - 動的メモリ確保
   - ガベージコレクションとの関係

4. **Go言語の特徴**
   - スライスの内部実装
   - パフォーマンス比較
