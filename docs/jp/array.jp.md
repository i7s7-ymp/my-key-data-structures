# 配列（Array）とは

配列は、同じ型の要素を連続したメモリ領域に格納するデータ構造です。各要素にはインデックス（添字）が割り当てられ、O(1)でランダムアクセスが可能です。

## 基本的な特徴

- 要素は連続したメモリ領域に格納される
- 各要素には 0 から始まるインデックスが割り当てられる
- 固定サイズ（静的配列）または動的サイズ（動的配列）がある
- 同じ型の要素のみを格納する

# 行える処理

## 基本操作

- **参照（Access）**: 特定のインデックスの要素を取得
- **更新（Update）**: 特定のインデックスの要素を変更
- **挿入（Insert）**: 新しい要素を配列に追加
- **削除（Delete）**: 特定のインデックスの要素を削除
- **検索（Search）**: 特定の値を持つ要素を探索

# 得意な処理（O(1)の操作）

## ランダムアクセス

- **インデックス指定でのアクセス**
  - 計算量: **O(1)**
  - インデックスの値や要素の数に関わらず、常に一定時間でアクセス可能
  - メモリアドレスの計算: `基準アドレス + (インデックス × 要素サイズ)`

## 要素の更新

- **特定インデックスの値を変更**
  - 計算量: **O(1)**
  - インデックスが分かっていれば即座に変更可能

## 末尾への挿入（動的配列の場合）

- **配列の最後に要素を追加**
  - 計算量: **O(1)** (平均的な場合)
  - リサイズが必要な場合は O(n)になることがある

# 苦手な処理（O(n)の操作）

## 中間位置への挿入

- **特定のインデックスに要素を挿入**
  - 計算量: **O(n)**
  - 挿入位置より後ろの全要素を 1 つずつ後ろにシフトする必要がある
  - 最悪の場合（先頭に挿入）は全要素をシフト

## 中間位置からの削除

- **特定のインデックスの要素を削除**
  - 計算量: **O(n)**
  - 削除位置より後ろの全要素を 1 つずつ前にシフトする必要がある
  - 最悪の場合（先頭から削除）は全要素をシフト

## 要素の検索

- **特定の値を持つ要素を探索**
  - 計算量: **O(n)**（線形探索の場合）
  - ソート済み配列の場合は二分探索で O(log n)に改善可能
  - 最悪の場合、全要素を確認する必要がある

## 配列全体の操作

- **全要素の走査**
  - 計算量: **O(n)**
- **配列のコピー**
  - 計算量: **O(n)**

# Go と Python における配列の比較

## Go 言語の配列

### 静的配列（Array）

```go
// 固定サイズの配列
var arr [5]int = [5]int{1, 2, 3, 4, 5}
```

**特徴:**

- **固定サイズ**: 宣言時にサイズが決まり、実行時に変更不可
- **値型**: 配列全体が値として扱われる（コピー時は全要素がコピーされる）
- **メモリ効率**: 連続したメモリ領域に格納され、メモリ使用量が予測可能
- **型安全**: コンパイル時に型チェックが行われる

### スライス（Slice）- 動的配列

```go
// 動的サイズのスライス
var slice []int = []int{1, 2, 3, 4, 5}
slice = append(slice, 6) // 動的に要素を追加
```

**特徴:**

- **動的サイズ**: 実行時にサイズを変更可能
- **参照型**: 内部的には配列への参照を持つ
- **自動リサイズ**: 容量が足りなくなると自動的に拡張される
- **高性能**: append 操作は平均的に O(1)

## Python のリスト

```python
# Pythonのリスト（動的配列）
arr = [1, 2, 3, 4, 5]
arr.append(6)  # 末尾に追加
arr.insert(2, 10)  # 特定位置に挿入
```

**特徴:**

- **動的サイズ**: 実行時にサイズを自由に変更可能
- **異なる型を混在可能**: `[1, "hello", 3.14, True]` のような配列も作成可能
- **豊富な組み込みメソッド**: `append()`, `insert()`, `remove()`, `pop()` など
- **参照型**: オブジェクトへの参照を格納

## 比較表

| 特徴                 | Go 配列      | Go スライス  | Python リスト |
| -------------------- | ------------ | ------------ | ------------- |
| **サイズ**           | 固定         | 動的         | 動的          |
| **型の制約**         | 同一型のみ   | 同一型のみ   | 異なる型可能  |
| **メモリ効率**       | 高い         | 高い         | 中程度        |
| **ランダムアクセス** | O(1)         | O(1)         | O(1)          |
| **末尾追加**         | 不可         | O(1)平均     | O(1)平均      |
| **中間挿入**         | -            | O(n)         | O(n)          |
| **要素削除**         | -            | O(n)         | O(n)          |
| **型安全性**         | コンパイル時 | コンパイル時 | 実行時        |

## パフォーマンスの違い

### Go 言語の利点

- **コンパイル型**: コンパイル時最適化により高速実行
- **メモリ管理**: ガベージコレクションが効率的
- **型安全**: コンパイル時にエラーを検出

### Python の利点

- **柔軟性**: 異なる型の要素を混在可能
- **豊富な機能**: 多くの組み込みメソッドと関数
- **簡潔な記法**: リスト内包表記などの便利な機能

## 実用的な使い分け

### Go を選ぶべき場面

- 高いパフォーマンスが必要
- メモリ使用量を厳密に管理したい
- 型安全性を重視する
- システムプログラミングや並行処理

### Python を選ぶべき場面

- 開発速度を重視する
- データ分析や機械学習
- プロトタイピング
- 柔軟なデータ構造が必要
