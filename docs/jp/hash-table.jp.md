# ハッシュテーブル（Hash Table）とは

ハッシュテーブルは、キーと値のペアを効率的に格納・検索するデータ構造です。ハッシュ関数を使用してキーを配列のインデックスにマッピングすることで、値の検索・追加・削除を高速に行うことができます。

## 基本的な特徴

- **キー・バリュー型**: キーと値のペアでデータを管理
- **ハッシュ関数**: キーを配列のインデックスに変換する関数
- **高速アクセス**: 平均的に O(1)でのデータアクセス
- **動的サイズ**: 必要に応じてサイズを拡張可能
- **衝突処理**: 異なるキーが同じインデックスにマッピングされる問題への対処

## ハッシュテーブルの構成要素

### ハッシュ関数

- キーを配列のインデックスに変換する関数
  - key をそのまま index に利用する場合もあるが、文字列などの場合はそのまま利用できない
- 良いハッシュ関数の条件：
  - 高速に計算できる
  - 値が均等に分散される
  - 決定的（同じキーは常に同じ値を返す）
- 完全ハッシュ関数
  - どのキーに対しても、ハッシュ値が異なるハッシュ関数
  - すべての異なるキーがユニークなインデックスにマッピングされ、データの挿入・検索・削除は配列への直接アクセスとなり、計算量は $O(1) となる

### バケット配列

- 実際にデータを格納する配列
- 各要素（バケット）にキー・バリューペアを格納

### 衝突を解決する方法

現実では完全ハッシュ関数を作ることは難しく、異なるキーが同じ idnex にマッピング（衝突）されてしまう。
衝突を効率よく解決する方法は主に 2 つある。

- **チェイン法**: 同じインデックスの要素を連結リストで管理
- **オープンアドレス法**: 別の空いているインデックスを探す

#### チェイン法

- 仕組み
  - ハッシュテーブル保存時、衝突が発生したデータを連結リストに保存し。そのハッシュ値の index を持つバケットにはデータが保存された連結リストへのポインタを持たせる
    1. キーからハッシュ値を計算し、対応するバケットを選択
    2. バケットがからなら、新しいデータを格納
    3. バケットにデータが存在していたら、バケットが指す連結リストの末尾に新しいデータを追加
- 長所
  - 実装が比較的簡単
  - ハッシュテーブルが満杯になっても、要素を無限に追加可能
  - 要素の削除が非常に簡単（連結リストからノードを削除するだけ）
- 短所
  - 連結リスト管理のために追加のメモリが必要
  - 一つの連結リストが極端に長くなると、連結リストの検索性能が線形探索と同じになり、遅くなる（最悪 O(n)）
  - 連結リストをたどる際にメモリアクセスが非連続的になるため、CPU キャッシュ効率が悪くなることがある
- 向いているケース
  - データの追加・削除が頻繁に発生する
  - 格納するデータ量が予測しにくい

#### オープンアドレス法

- 仕組み
  - ハッシュテーブル内の空いている別のバケットを探してデータを格納する。外部のデータ構造を利用せず、全て絵のデータはえテーブルの配列内に直接保存される
  - 空きバケットの探し方（探査法）にいくつか種類がある
- 探査法の種類
  - 線形探査法
    - 衝突したバケットを基準に隣のバケットを順番に見ていく
    - 一次クラスタリングの問題: データが連続したブロック（クラスタ）を作りやすくなり、クラスタが大きくなると新しいデータを挿入する際に何度も衝突が起き、性能が悪化する
  - 二乗探査法
    - 衝突したバケットを基準に n\*\*2（1, 4, 9,...）離れたバケットを見ていく
    - 一次クラスタリングを緩和できるが、二次クラスタリングという、特定のパターンで衝突が連鎖する問題が起こることがある
  - ダブルハッシュ法
    - 2 種類のハッシュを用意する。最も効率が良い。
      1. 最初のハッシュ関数で格納位置を計算
      2. 衝突したら、2 番目のハッシュ関数で「次の候補を探すための間隔」を計算し、その間隔でバケットを探索
    - 探査の間隔がキーごとに異なり、クラスタリングが非常に発生しにくく、高いパフォーマンスを維持できる
- 長所
  - ポインタを使わないので、追加のメモリが不要で、メモリ効率が良い
  - データが配列内に密集しているので、CPU のキャッシュ効率が良い傾向にある
- 短所
  - テーブルが満杯に近づくと性能が急激に低下
  - 要素の削除が複雑。単純にデータを削除すると、探査の連鎖が途切れてしまい、その先にあるはずのデータが見つからなくなる可能性がある。利用する場合は「削除済み」を表す特別なマーカーを置く
  - ハッシュテーブルのサイズをあらかじめ設計する必要がある
- 向いているケース
  - メモリ使用量を厳密に管理したい
  - データの追加・削除が少なく、読み取りが中心
  - テーブルの負荷率を小さく保てる

## 連想配列

- key と value のペアをひとまとめにして管理する抽象的なデータ型
  - 辞書や map とも呼ばれる
- 任意のキーを指定して、対応する値を効率的に格納・取得・削除できる
- ハッシュテーブルや平衡二分木を用いて実装される

# 行える処理

## 基本操作

### 挿入操作（Insert/Put）

- **新しいキー・バリューペアを追加**
- キーが既に存在する場合は値を更新

### 検索操作（Search/Get）

- **指定したキーに対応する値を取得**
- キーが存在しない場合は「見つからない」を返す

### 削除操作（Delete/Remove）

- **指定したキーとその値を削除**
- キーが存在しない場合は何もしない

### 存在確認操作（Contains/Has）

- **指定したキーが存在するかチェック**
- 真偽値を返す

## 補助操作

### サイズ取得

- **格納されている要素数を取得**

### 空判定

- **ハッシュテーブルが空かどうかを確認**

### 全要素の走査

- **すべてのキー・バリューペアを順次処理**

# 得意な処理（効率的な操作）

## データの検索

- **計算量**: **O(1)** (平均)
- ハッシュ関数により直接インデックスを計算
- 配列や連結リストと比べて圧倒的に高速

## データの挿入

- **計算量**: **O(1)** (平均)
- 既存データの移動が不要
- 動的にサイズを拡張可能

## データの削除

- **計算量**: **O(1)** (平均)
- 他の要素への影響が最小限
- 削除後の再配置が不要

## キーの存在確認

- **計算量**: **O(1)** (平均)
- 値を取得せずに存在だけを高速確認

# 苦手な処理（非効率的な操作）

## ソートされた順序での取得

- **計算量**: **O(n log n)**
- ハッシュテーブルは順序を保持しない
- ソートが必要な場合は別途処理が必要

## 最小値・最大値の検索

- **計算量**: **O(n)**
- 全要素を走査する必要がある
- 専用のデータ構造（ヒープなど）の方が効率的

## 範囲検索

- **計算量**: **O(n)**
- 特定の範囲内の値を効率的に取得できない
- B 木などの方が適している

## メモリ使用量

- **空間効率**: 負荷率に依存
- 衝突を避けるため、使用率を低く保つ必要がある
- メモリの無駄が発生しやすい

## 最悪ケースの性能

- **計算量**: **O(n)** (最悪の場合)
- すべてのキーが同じインデックスにマッピングされる場合
- ハッシュ関数の品質に依存

# Go 言語での実装

## 基本的な構造体

```go
// キー・バリューペア
type KeyValue struct {
    Key   string
    Value interface{}
    Next  *KeyValue // チェイン法用のポインタ
}

// ハッシュテーブル構造体
type HashTable struct {
    Buckets []*KeyValue // バケット配列
    Size    int         // 現在の要素数
    Capacity int        // バケットの容量
}
```

## ハッシュ関数の実装

```go
// シンプルなハッシュ関数（djb2アルゴリズム）
func (ht *HashTable) hash(key string) int {
    hash := 5381
    for _, char := range key {
        hash = ((hash << 5) + hash) + int(char)
    }
    return hash % ht.Capacity
}
```

## 基本操作の実装

### 挿入操作 O(1)平均

```go
func (ht *HashTable) Put(key string, value interface{}) {
    index := ht.hash(key)

    // 既存のキーをチェック
    current := ht.Buckets[index]
    for current != nil {
        if current.Key == key {
            current.Value = value // 値を更新
            return
        }
        current = current.Next
    }

    // 新しいキー・バリューペアを先頭に挿入
    newNode := &KeyValue{
        Key:   key,
        Value: value,
        Next:  ht.Buckets[index],
    }
    ht.Buckets[index] = newNode
    ht.Size++
}
```

### 検索操作 O(1)平均

```go
func (ht *HashTable) Get(key string) (interface{}, bool) {
    index := ht.hash(key)
    current := ht.Buckets[index]

    for current != nil {
        if current.Key == key {
            return current.Value, true
        }
        current = current.Next
    }

    return nil, false // キーが見つからない
}
```

### 削除操作 O(1)平均

```go
func (ht *HashTable) Delete(key string) bool {
    index := ht.hash(key)
    current := ht.Buckets[index]
    var prev *KeyValue

    for current != nil {
        if current.Key == key {
            if prev == nil {
                // 先頭要素の削除
                ht.Buckets[index] = current.Next
            } else {
                // 中間要素の削除
                prev.Next = current.Next
            }
            ht.Size--
            return true
        }
        prev = current
        current = current.Next
    }

    return false // キーが見つからない
}
```

### 存在確認 O(1)平均

```go
func (ht *HashTable) Contains(key string) bool {
    _, exists := ht.Get(key)
    return exists
}
```

## 補助メソッド

### ハッシュテーブルの作成

```go
func NewHashTable(capacity int) *HashTable {
    return &HashTable{
        Buckets:  make([]*KeyValue, capacity),
        Size:     0,
        Capacity: capacity,
    }
}
```

### 全要素の表示

```go
func (ht *HashTable) Display() {
    fmt.Printf("ハッシュテーブル (サイズ: %d, 容量: %d)\n", ht.Size, ht.Capacity)
    for i, bucket := range ht.Buckets {
        if bucket != nil {
            fmt.Printf("バケット[%d]: ", i)
            current := bucket
            for current != nil {
                fmt.Printf("(%s: %v)", current.Key, current.Value)
                if current.Next != nil {
                    fmt.Print(" -> ")
                }
                current = current.Next
            }
            fmt.Println()
        }
    }
}
```

### 負荷率の計算

```go
func (ht *HashTable) LoadFactor() float64 {
    return float64(ht.Size) / float64(ht.Capacity)
}
```

## 使用例

```go
func main() {
    // ハッシュテーブルを作成
    ht := NewHashTable(10)

    // データの挿入
    ht.Put("apple", 100)
    ht.Put("banana", 200)
    ht.Put("orange", 150)
    ht.Put("grape", 300)

    // データの検索
    if value, found := ht.Get("apple"); found {
        fmt.Printf("apple: %v\n", value)
    }

    // データの存在確認
    if ht.Contains("banana") {
        fmt.Println("banana が存在します")
    }

    // データの削除
    if ht.Delete("orange") {
        fmt.Println("orange を削除しました")
    }

    // ハッシュテーブルの表示
    ht.Display()

    // 負荷率の確認
    fmt.Printf("負荷率: %.2f\n", ht.LoadFactor())
}
```

## 他のデータ構造との比較

| 操作           | ハッシュテーブル | 配列     | 連結リスト | 二分探索木 |
| -------------- | ---------------- | -------- | ---------- | ---------- |
| **検索**       | O(1)平均         | O(n)     | O(n)       | O(log n)   |
| **挿入**       | O(1)平均         | O(1)末尾 | O(1)先頭   | O(log n)   |
| **削除**       | O(1)平均         | O(n)     | O(1)先頭   | O(log n)   |
| **順序保持**   | なし             | あり     | あり       | あり       |
| **メモリ効率** | 中程度           | 高い     | 中程度     | 中程度     |

ハッシュテーブルは、キーによる高速なデータアクセスが必要で、順序が重要でない場合に最適なデータ構造です。
